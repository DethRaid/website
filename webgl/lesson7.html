<html>

  <head>
    <title>WebGL Lesson 7</title>
    <meta http-equiv="context-type" content="text/html; charset-ISO-8859-1">

    <script type="text/javascript" src="gl-matrix-min.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D diffuse;

        varying vec2 vTexcoord;
        varying vec3 vNormal;
        varying vec3 vLightDir;

        void main() {
            float ndotl = dot( vNormal, vLightDir );
            if( ndotl < 0.0 ) {
                ndotl = 0.0;
            }
            vec3 color = texture2D( diffuse, vTexcoord ).rgb;
           // color = vec3( 1.0, 0.0, 0.0 );
            vec3 ambient = color * vec3( 0.2, 0.2, 0.2 );
            vec3 lit = color * ndotl;
            gl_FragColor = vec4( lit + ambient, 1 );
      }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 position_model;
        attribute vec2 texcoord;
        attribute vec3 normal;

      uniform mat4 MV;
      uniform mat4 P;
      uniform mat3 normalMatrix;

      varying vec2 vTexcoord;
      varying vec3 vNormal;
      varying vec3 vLightDir;
      varying mat3 vNormalMatrix;

      void main() {
          gl_Position = P * MV * vec4( position_model, 1.0 );
          vTexcoord = texcoord;
          vNormal = normalMatrix * normal;
          vLightDir = normalize( vec3( 1, 1, 1 ) );
      }
    </script>

    <script type="text/javascript">
      function degToRad( degrees ) {
          return degrees * Math.PI / 180;
      }

      var gl;

      function initGL( canvas ) {
        try {
          gl = canvas.getContext( "experimental-webgl" );
          gl.viewportWidth = canvas.width;
          gl.viewportHeight = canvas.height;
        } catch( e ) {
        }
        if( !gl ) {
          alert( "Could not initialize WebGL" );
        }
      }

      var texture;

      function initTexture() {
          texture = gl.createTexture();
          gl.bindTexture( gl.TEXTURE_2D, texture );
          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                  new Uint8Array( [255, 0, 255, 255] ) );

          texture.image = new Image();
          texture.image.onload = function() {
              texture.image.width = 32;
              texture.image.height = 32;
              handleLoadedTexture( texture );
          }
          texture.image.src = "TriSign.png";
      }

      function isPowerOf2( value ) {
          return (value & (value - 1)) == 0;
      }

      function handleLoadedTexture( texture ) {
          gl.bindTexture( gl.TEXTURE_2D, texture );
          gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );
          gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);

          if( isPowerOf2( texture.image.width ) && isPowerOf2( texture.image.height ) ) {
              gl.generateMipmap( gl.TEXTURE_2D ); 
              gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );
          } else {
              gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
              gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
              gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );
          }
          gl.bindTexture( gl.TEXTURE_2D, null );
      }

      function getShader( gl, id ) {
        var shaderScript = document.getElementById( id );
        if( !shaderScript ) {
          return null;
        }

        var shader;
        if( shaderScript.type == "x-shader/x-fragment" ) {
          shader = gl.createShader( gl.FRAGMENT_SHADER );
        } else if( shaderScript.type == "x-shader/x-vertex" ) {
          shader = gl.createShader( gl.VERTEX_SHADER );
        } else {
          return null;
        }
        
        gl.shaderSource( shader, shaderScript.textContent );
        gl.compileShader( shader );

        if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
          alert( shaderScript.textContent );
          alert( gl.getShaderInfoLog( shader ) );
          return null;
        }

        return shader;
      }

      var shaderProgram;

      function initShaders() {
        var fragmentShader = getShader( gl, "shader-fs" );
        var vertexShader = getShader( gl, "shader-vs" );

        shaderProgram = gl.createProgram();
        gl.attachShader( shaderProgram, vertexShader );
        gl.attachShader( shaderProgram, fragmentShader );
        gl.linkProgram( shaderProgram );

        if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
            alert( "Could not initialize shader" );
            alert( gl.getProgramInfoLog( shaderProgram ) );
        }

        gl.useProgram( shaderProgram );

        shaderProgram.position_model = gl.getAttribLocation( shaderProgram, "position_model" );
        gl.enableVertexAttribArray( shaderProgram.position_model );

        shaderProgram.texcoord = gl.getAttribLocation( shaderProgram, "texcoord" );
        gl.enableVertexAttribArray( shaderProgram.texcoord );

        shaderProgram.normal = gl.getAttribLocation( shaderProgram, "normal" );
        gl.enableVertexAttribArray( shaderProgram.normal );

        shaderProgram.projMatrix = gl.getUniformLocation( shaderProgram, "P" );
        shaderProgram.modelviewMatrix = gl.getUniformLocation( shaderProgram, "MV" );
        shaderProgram.normalMatrix = gl.getUniformLocation( shaderProgram, "normalMatrix" );

        shaderProgram.diffuse = gl.getUniformLocation( shaderProgram, "diffuse" );
      }

      var modelview = mat4.create();
      var mvMatrixStack = [];
      var projection = mat4.create();

      function mvPushMatrix( mat ) {
          var copy = mat4.create();
          mat4.copy( copy, mat );
          mvMatrixStack.push( copy );
      }

      function mvPopMatrix() {
          if( mvMatrixStack.lenght == 0 ) {
              throw "Invalid popMatrix!";
          }
          modelview = mvMatrixStack.pop();
      }

      function setMatrixUniforms() {
        gl.uniformMatrix4fv( shaderProgram.projMatrix, false, projection );
        gl.uniformMatrix4fv( shaderProgram.modelviewMatrix, false, modelview );

        var normalMatrix = mat3.create();
        mat3.fromMat4( normalMatrix, modelview );
        mat3.invert( normalMatrix, normalMatrix );
        mat3.transpose( normalMatrix, normalMatrix );
        gl.uniformMatrix3fv( shaderProgram.normalMatrix, false, normalMatrix );
      }
     
      var squareBuffer;

      function initBuffers() {
        squareBuffer = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer );
        var data = [
             1.0,  1.0,  1.0, 1.0, 1.0,  0.333,  0.333,  0.333,
             1.0,  1.0, -1.0, 0.0, 1.0,  0.333,  0.333, -0.333,
             1.0, -1.0,  1.0, 1.0, 0.0,  0.333, -0.333,  0.333,
             1.0, -1.0, -1.0, 0.0, 0.0,  0.333, -0.333, -0.333,
            -1.0,  1.0,  1.0, 0.0, 1.0, -0.333,  0.333,  0.333,
            -1.0,  1.0, -1.0, 1.0, 1.0, -0.333,  0.333, -0.333,
            -1.0, -1.0,  1.0, 0.0, 0.0, -0.333, -0.333,  0.333,
            -1.0, -1.0, -1.0, 1.0, 0.0, -0.333, -0.333, -0.333
        ];
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( data ), gl.STATIC_DRAW );
        squareBuffer.numItems = 8;

        squareBuffer.indices = gl.createBuffer();
        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices );
        var cubeVertexIndices = [
            6, 2, 0,    6, 0, 4,
            7, 5, 1,    7, 1, 3,
            5, 4, 0,    5, 0, 1,
            7, 3, 2,    7, 2, 6,
            3, 1, 0,    3, 0, 2,
            7, 6, 4,    7, 4, 5
        ];
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( cubeVertexIndices ), gl.STATIC_DRAW );
        squareBuffer.indices.itemSize = 1;
        squareBuffer.indices.numItems = 36;
      }

      var pressedKeys = {};
    
      function handleKeyDown( event ) {
          pressedKeys[event.keyCode] = true; 
      }

      function handleKeyUp( event ) {
          pressedKeys[event.keyCode] = false;
      }

      function tick() {
          requestAnimationFrame( tick );
          handleKeys();
          drawScene();
          animate();
      }

      function handleKeys() {
          if( pressedKeys[37] ) {   //left arrow
              yRot++;
          }
          if( pressedKeys[39] ) {   //right arrow
              yRot--;
          }
          if( pressedKeys[38] ) {   //up arrow
              xRot++;
          }
          if( pressedKeys[40] ) {   //down arrow
              xRot--;
          }
      }


      var xRot = 0;
      var yRot = 0;

      function drawScene() {
        gl.viewport( 0, 0, gl.viewportWidth, gl.viewportHeight );
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        mat4.perspective( projection, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0 );

        mat4.identity( modelview );

        mvPushMatrix( modelview );
        mat4.rotateX( modelview, modelview, degToRad( xRot ) );
        mat4.rotateY( modelview, modelview, degToRad( yRot ) );
        
        mat4.translate( modelview, modelview, [0.0, 0.0, -7.0] );


        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer );
        gl.vertexAttribPointer( shaderProgram.position_model, 3, gl.FLOAT, false, 32, 0 );
        gl.vertexAttribPointer( shaderProgram.texcoord, 2, gl.FLOAT, false, 32, 12 );
        gl.vertexAttribPointer( shaderProgram.normal, 3, gl.FLOAT, false, 32, 20 );

        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture( gl.TEXTURE_2D, texture );
        gl.uniform1i( shaderProgram.diffuse, 0 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices );
        setMatrixUniforms();
        gl.drawElements( gl.TRIANGLES, squareBuffer.indices.numItems, gl.UNSIGNED_SHORT, 0 );

        mvPopMatrix();
      }

      var lastTime = 0;
      function animate() {
          var timeNow = new Date().getTime();
          if( lastTime != 0 ) {
              var elapsed = timeNow - lastTime;
          }
          lastTime = timeNow;
      }

      function webGLStart() {
        var canvas = document.getElementById( "lesson01-canvas" );
        initGL( canvas );
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
        gl.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LESS );

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
      }

    </script>

  </head>

  <body onload="webGLStart();">
    <canvas id="lesson01-canvas" style="border:none;" width="500" height="500"></canvas>
  </body>
</html>

