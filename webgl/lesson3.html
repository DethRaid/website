<html>

  <head>
    <title>WebGL Lesson 3</title>
    <meta http-equiv="context-type" content="text/html; charset-ISO-8859-1">

    <script type="text/javascript" src="gl-matrix-min.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 vColor;

      void main() {
        gl_FragColor = vColor;
      }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 position_model;
        attribute vec4 color;

      uniform mat4 MV;
      uniform mat4 P;

      varying vec4 vColor;

      void main() {
          gl_Position = P * MV * vec4( position_model, 1.0 );
          vColor = color;
      }
    </script>

    <script type="text/javascript">
      function degToRad( degrees ) {
          return degrees * Math.PI / 180;
      }

      var gl;

      function initGL( canvas ) {
        try {
          gl = canvas.getContext( "experimental-webgl" );
          gl.viewportWidth = canvas.width;
          gl.viewportHeight = canvas.height;
        } catch( e ) {
        }
        if( !gl ) {
          alert( "Could not initialize WebGL" );
        }
      }

      function getShader( gl, id ) {
        var shaderScript = document.getElementById( id );
        if( !shaderScript ) {
          return null;
        }

        var shader;
        if( shaderScript.type == "x-shader/x-fragment" ) {
          shader = gl.createShader( gl.FRAGMENT_SHADER );
        } else if( shaderScript.type == "x-shader/x-vertex" ) {
          shader = gl.createShader( gl.VERTEX_SHADER );
        } else {
          return null;
        }
        
        gl.shaderSource( shader, shaderScript.textContent );
        gl.compileShader( shader );

        if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
          alert( shaderScript.textContent );
          alert( gl.getShaderInfoLog( shader ) );
          return null;
        }

        return shader;
      }

      var shaderProgram;

      function initShaders() {
        var fragmentShader = getShader( gl, "shader-fs" );
        var vertexShader = getShader( gl, "shader-vs" );

        shaderProgram = gl.createProgram();
        gl.attachShader( shaderProgram, vertexShader );
        gl.attachShader( shaderProgram, fragmentShader );
        gl.linkProgram( shaderProgram );

        if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
          alert( "Could not initialize shader" );
        }

        gl.useProgram( shaderProgram );

        shaderProgram.position_model = gl.getAttribLocation( shaderProgram, "position_model" );
        gl.enableVertexAttribArray( shaderProgram.position_model );

        shaderProgram.color = gl.getAttribLocation( shaderProgram, "color" );
        gl.enableVertexAttribArray( shaderProgram.color );

        shaderProgram.projMatrix = gl.getUniformLocation( shaderProgram, "P" );
        shaderProgram.modelviewMatrix = gl.getUniformLocation( shaderProgram, "MV" );
      }

      var modelview = mat4.create();
      var mvMatrixStack = [];
      var projection = mat4.create();

      function mvPushMatrix( mat ) {
          var copy = mat4.create();
          mat4.copy( copy, mat );
          mvMatrixStack.push( copy );
      }

      function mvPopMatrix() {
          if( mvMatrixStack.lenght == 0 ) {
              throw "Invalid popMatrix!";
          }
          modelview = mvMatrixStack.pop();
      }

      function setMatrixUniforms() {
        gl.uniformMatrix4fv( shaderProgram.projMatrix, false, projection );
        gl.uniformMatrix4fv( shaderProgram.modelviewMatrix, false, modelview );
      }

      var triangleBuffer;
      var squareBuffer;

      function initBuffers() {
          triangleBuffer = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, triangleBuffer );
        var vertices = [
          0.0, 1.0, 0.0,
          -1.0, -1.0, 0.0,
          1.0, -1.0, 0.0
        ];
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( vertices ), gl.STATIC_DRAW );
        triangleBuffer.itemSize = 3;
        triangleBuffer.numItems = 3;

        triangleBuffer.colors = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, triangleBuffer.colors );
        var colors = [
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0
        ];
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( colors ), gl.STATIC_DRAW );
        triangleBuffer.colors.itemSize = 4;
        triangleBuffer.colors.numItems = 3;

        squareBuffer = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer );
        vertices = [
          1.0,  1.0, 0.0,
         -1.0,  1.0, 0.0,
          1.0, -1.0, 0.0,
         -1.0, -1.0, 0.0
        ];
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( vertices ), gl.STATIC_DRAW );
        squareBuffer.itemSize = 3;
        squareBuffer.numItems = 4;

        squareBuffer.colors = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer.colors );
        colors = [];
        for( var i = 0; i < 4; i++ ) {
            colors = colors.concat( [0.5, 0.5, 1.0, 1.0] );
        }
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( colors ), gl.STATIC_DRAW );
        squareBuffer.colors.itemSize = 4;
        squareBuffer.colors.numItems = 4;
      }

      function tick() {
          requestAnimationFrame( tick );
          drawScene();
          animate();
      }

      var rTri = 0;
      var rSquare = 0;

      function drawScene() {
        gl.viewport( 0, 0, gl.viewportWidth, gl.viewportHeight );
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        mat4.perspective( projection, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0 );

        mat4.identity( modelview );
        mat4.translate( modelview, modelview, [-1.5, 0.0, -7.0] );

        mvPushMatrix( modelview );
        mat4.rotateY( modelview, modelview, degToRad( rTri ) );

        gl.bindBuffer( gl.ARRAY_BUFFER, triangleBuffer );
        gl.vertexAttribPointer( shaderProgram.position_model, triangleBuffer.itemSize, gl.FLOAT, false, 0, 0 );

        gl.bindBuffer( gl.ARRAY_BUFFER, triangleBuffer.colors );
        gl.vertexAttribPointer( shaderProgram.color, triangleBuffer.colors.itemSize, gl.FLOAT, false, 0, 0 );

        setMatrixUniforms();
        gl.drawArrays( gl.TRIANGLES, 0, triangleBuffer.numItems );

        mvPopMatrix();

        mat4.translate( modelview, modelview, [3.0, 0.0, 0.0] );

        mvPushMatrix( modelview );
        mat4.rotateX( modelview, modelview, degToRad( rSquare ) );

        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer );
        gl.vertexAttribPointer( shaderProgram.position_model, squareBuffer.itemSize, gl.FLOAT, false, 0, 0 );

        gl.bindBuffer( gl.ARRAY_BUFFER, squareBuffer.colors );
        gl.vertexAttribPointer( shaderProgram.color, squareBuffer.colors.itemSize, gl.FLOAT, false, 0, 0 );

        setMatrixUniforms();
        gl.drawArrays( gl.TRIANGLE_STRIP, 0, squareBuffer.numItems );

        mvPopMatrix();
      }

      var lastTime = 0;
      function animate() {
          var timeNow = new Date().getTime();
          if( lastTime != 0 ) {
              var elapsed = timeNow - lastTime;
            
              rTri += (90 * elapsed) / 1000.0;
              rSquare += (75 * elapsed) / 1000.0;
          }
          lastTime = timeNow;
      }

      function webGLStart() {
        var canvas = document.getElementById( "lesson01-canvas" );
        initGL( canvas );
        initShaders();
        initBuffers();

        gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
        gl.enable( gl.DEPTH_TEST );

        tick();
      }

    </script>

  </head>

  <body onload="webGLStart();">
    <canvas id="lesson01-canvas" style="border:none;" width="500" height="500"></canvas>
  </body>
</html>

